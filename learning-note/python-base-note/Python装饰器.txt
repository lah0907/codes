Python装饰器
1.函数作用域
2.闭包
3.装饰器


1.函数作用域LEGB
	LEGB:
		L > E > G > B
	L：local函数内部作用域
	E：enclosing函数内部与内嵌函数之间
	G：global全局作用域
	B：built-in内置作用域
	示例：
		#coding:utf-8
		passline = 60
		def func(val):
			passline = 90
			if val >= passline:
				print('pass')
			else:
				print('failed')

			def in_func():
				print(val)  # val在方法本地内部作用于不存在，到 E 中查找

			in_func()

2.闭包理解与使用
闭包概念：
	closure：内部函数中对 enclosing 作用域的变量进行引用
函数的实质与属性：
	(1)函数是一个对象
	(2)函数执行完成后内部变量回收
	(3)函数属性
	(4)函数返回值
	示例：
		#coding:utf-8
		passline = 60
		def func(val):
			passline = 90
			if val >= passline:
				print('pass')
			else:
				print('failed')

			def in_func():  # (val,) # 把val封装为元组，不可变
				print(val)  # val在方法本地内部作用于不存在，到 E 中查找

			in_func()
			return in_func() # 返回这个内部函数，则这个函数在执行结束后，还有引用，不能被回收

		测试：
			f = func(89)
			f()
			print(f.__closure__)

		改造代码过程：
			def func_150(val):
				passline = 90
				if val >= passline:
					print('s% pass' %val)
				else:
					print('s% failed' %val)

			def func_100(val):
				passline = 60
				if val >= passline:
					print('s% pass' %val)
				else:
					print('s% failed' %val)



			def func(val,full_mark):
				passline = full_mark * 0.6
				if val >= passline:
					print('s% pass' %val)
				else:
					print('s% failed' %val)

		-----------------------------------------


			def set_passline(passline):
			 # passline是获取内置函数时需要传递的参数，且这个参数在内置函数中被使用

				def cmp(val):  # val为调用内置函数时需要传递的参数
					if val >= passline:
						print('Pass')
					else:
						print('failed')
				return cmp

			测试：
				f_100 = set_passline(60)
				print(type(f_100))
				print(f_100.__closure__)
				f_100(89)
				f_100(59)

				f_150 = set_passline(90)
				f_150(89)

		闭包就是内置函数对 enclosing作用域中变量的使用，它会将变量放到__closure__属性中
		闭包的作用：
			-封装
			-代码复用


		示例：
			#coding:utf-8
			def my_sum(*arg):
				if len(arg) == 0:
					return 0
				for val in arg:
					if not isinstance(val, int):
						return 0
				return sum(arg)

			def my_average(*arg):
				if len(arg) == 0:
					return 0
				for val in arg:
					if not isinstance(val, int):
						return 0
				return sum(ars)/len(arg)

			print(my_sum(1, 2, 3, 4, 5, '6'))
			print(my_average())



			def my_sum(*arg):
				print('in my_sum')
				return sum(arg)

			def my_average(*arg):
				return sum(ars)/len(arg)

			def dec(func):
				def in_dec(*arg):  # 内置函数的作用是检查参数arg，合格后在传递给可用函数
					print('in dec arg = ', arg)
					if len(arg) == 0:
						return 0
					for val in arg:
						if not isinstance(val, int):
							return 0
					return func(*arg)

				return in_dec

			测试：
				my_sum = dec(my_sum)
				my_sum(1, 2, 3)


3.装饰器
	(1)装饰器用来装饰函数
	(2返回一个函数对象
	(3)被装饰函数标识符指向返回的函数对象
	(4)语法糖 @deco

	装饰器就是对闭包的一种使用

	示例1：
			def dec(func):
				def in_dec(*arg):
					print('in dec arg = ', arg)
					if len(arg) == 0:
						return 0
					for val in arg:
						if not isinstance(val, int):
							return 0
					return func(*arg)

				return in_dec

			@dec #装饰器语法糖，会调用dec函数以my_sum作为参数，将返回值 in_dec 赋值给 my_sum
			def my_sum(*arg):
				print('in my_sum')
				return sum(arg)

			# @dec 是装饰器语法糖，
			# 会把my_sum作为参数传递给dec函数并调用dec函数，将返回值赋值给 my_sum
			# 它效果相当于 my_sum = dec(my_sum)，但是这里省略掉了这个函数调用过程


			测试：
				print(my_sum(1,2,3,4)) 


	示例2：
		def deco(func):
			def in_deco():
				print('in deco')
				func()
			print('call deco')
			# return in_deco

		@deco
		def bar():
			print('in bar')

		测试：
			print(type(bar))
			bar()
			# deco函数没有返回 in_deco时，结果是 call deco,<class,None>,抛出异常
			# deco函数返回 in_deco时，结果是 call deco,<class,function>,in deco,in bar

	示例3：
		def deco(func):
		    def in_deco(x,y): 
		    # 由于func中需要变量作为参数，所以需要在此定义形参，或者func写上常量，但无意义
		        print 'in deco'
		        func(x,y) # 与bar函数的参数对应
		    print 'call deco'
		    return in_deco

		@deco
		def bar(x,y):
		    print 'in bar' , x + y

		测试：
		bar(1,2)
		结果：
			call deco
			in deco
			in bar 3










